<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>寿限無タイピング</title>
<style>
  :root{
    --bg1:#ffe8c6;
    --bg2:#ffd3ef;
    --ink:#1f2937;
    --muted:#5f6b7a;
    --accent:#e50071;
    --accent2:#03738a;
    --accent3:#ff7f00;
    --panel:transparent;
    --ok:#16a34a;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:"Hiragino Maru Gothic ProN","Yu Gothic UI","Yu Gothic","Hiragino Kaku Gothic ProN","Meiryo",sans-serif;
    color:var(--ink);
    background:
      radial-gradient(1200px 600px at 20% -10%, rgba(255,127,0,.28) 0, transparent 62%),
      radial-gradient(800px 500px at 90% 10%, rgba(229,0,113,.22) 0, transparent 62%),
      linear-gradient(160deg,var(--bg1),var(--bg2));
    min-height:100dvh;
    display:flex;
    align-items:flex-start;
    justify-content:center;
    padding:18px;
    overflow-x:hidden;
  }
  body.no-scroll{
    position:fixed;
    inset:0;
    width:100%;
    height:100dvh;
    overflow:hidden;
    touch-action:none;
  }
  .bg-photo{
    position:fixed;
    inset:0;
    z-index:0;
    pointer-events:none;
    overflow:hidden;
  }
  .bg-photo::after{
    content:"";
    position:absolute;
    inset:0;
    background:
      radial-gradient(circle at 12% 14%, rgba(255,127,0,.40), transparent 40%),
      radial-gradient(circle at 88% 18%, rgba(229,0,113,.34), transparent 42%),
      linear-gradient(160deg, rgba(3,115,138,.22), rgba(3,115,138,.10));
  }
  .bg-photo .bg-fill{
    width:100%;
    height:100%;
    object-fit:cover;
    object-position:50% 42%;
    opacity:.7;
    filter:saturate(1.18) contrast(1.06) blur(2px);
    transform:scale(1.05);
  }
  .bg-photo .bg-main{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center 62%;
    opacity:.78;
    filter:saturate(1.08) contrast(1.03);
  }
  .app{
    width:min(960px,100%);
    background:var(--panel);
    backdrop-filter:none;
    border-radius:20px;
    padding:12px;
    box-shadow:none;
    position:relative;
    z-index:1;
  }
  h1{
    margin:0 0 12px;
    font-size:34px;
    letter-spacing:.04em;
    font-weight:900;
    color:#fff8ef;
    text-shadow:0 4px 12px rgba(45,12,29,.35);
  }
  .muted{color:var(--muted)}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  .card{
    background:rgba(255,255,255,.24);
    border-radius:16px;
    padding:18px;
    box-shadow:0 14px 26px rgba(24,12,38,.22);
    border:1px solid rgba(255,255,255,.36);
    backdrop-filter: blur(8px);
  }
  .btn{
    border:none; border-radius:12px;
    padding:12px 20px; font-size:16px; font-weight:800;
    background:linear-gradient(120deg, var(--accent), #ff4fa4);
    color:white; cursor:pointer;
    box-shadow:0 10px 24px rgba(229,0,113,.35);
  }
  .btn.secondary{
    background:linear-gradient(120deg,var(--accent2), #0aa0bc);
    box-shadow:0 10px 24px rgba(3,115,138,.34);
  }
  .btn.ghost{background:#f3f4f6; color:#111; box-shadow:none}
  .screen{display:none}
  .screen.active{display:block}
  .input{
    font-size:16px; padding:10px 12px; border-radius:12px;
    border:2px solid rgba(255,127,0,.4);
    width:220px;
    background:rgba(255,255,255,.62);
  }
  #name{
    font-size:15px;
    height:40px;
    padding:8px 12px;
    width:190px;
  }
  #name::placeholder{
    color:#9aa5b5;
  }
  .input:focus{
    outline:none;
    border-color:var(--accent);
    box-shadow:0 0 0 4px rgba(229,0,113,.12);
  }
  .kana{
    font-size:30px;
    font-weight:800;
    line-height:1.55;
    letter-spacing:.02em;
    word-break:break-all;
    color:#1d2430;
    text-shadow:0 1px 0 rgba(255,255,255,.28);
  }
  .kana .next{
    background:#ffdcae;
    border-radius:8px;
    padding:2px 6px;
    color:#a74600;
  }
  .kana .done{
    color:#97a2b3;
  }
  .kanji{
    color:#263649;
    font-size:27px;
    font-weight:900;
    letter-spacing:.01em;
    line-height:1.4;
    margin-bottom:6px;
    text-shadow:0 1px 0 rgba(255,255,255,.3);
  }
  .stats{
    display:flex; gap:16px; flex-wrap:wrap;
  }
  .stat{font-weight:700}
  .stat{
    background:rgba(255,255,255,.55);
    border:1px solid rgba(255,255,255,.65);
    border-radius:999px;
    padding:6px 10px;
    font-weight:800;
    color:#334155;
  }
  .start-row{
    flex-direction:column;
    align-items:flex-start;
    gap:10px;
  }
  .start-row .input{
    width:100%;
    max-width:220px;
  }
  .start-row .btn{
    height:42px;
    width:100%;
    max-width:220px;
  }
  .progress-track{
    margin-top:10px;
    width:100%;
    height:10px;
    border-radius:999px;
    background:#f6cadf;
    overflow:hidden;
  }
  .progress-bar{
    width:0%;
    height:100%;
    background:linear-gradient(90deg,var(--accent3),var(--accent));
    transition:width .12s linear;
  }
  .countdown{
    font-size:48px; font-weight:800; text-align:center; margin:10px 0;
  }
  .ime-input{
    width:100%;
    margin-top:8px;
    padding:12px 14px;
    border-radius:12px;
    border:2px solid rgba(3,115,138,.35);
    background:rgba(255,255,255,.74);
    color:#1f2937;
    font-size:18px;
    font-weight:700;
    letter-spacing:.02em;
  }
  .ime-input:focus{
    outline:none;
    border-color:var(--accent2);
    box-shadow:0 0 0 4px rgba(3,115,138,.14);
  }
  .ime-input.desktop-hidden{
    position:fixed;
    left:-9999px;
    bottom:0;
    width:1px;
    height:1px;
    opacity:0;
    pointer-events:none;
    border:none;
    background:transparent;
    margin:0;
    padding:0;
  }
  .ime-input.mobile-hidden{
    display:none;
  }
  .warn{
    color:#b45309;
    background:rgba(255,247,237,.92);
    border:1px solid rgba(254,215,170,.95);
    padding:8px 10px;
    border-radius:10px;
    margin-top:8px;
  }
  .flick-wrap{
    margin-top:10px;
    background:rgba(255,255,255,.46);
    border:1px solid rgba(255,255,255,.55);
    border-radius:14px;
    padding:12px;
    box-shadow:0 8px 20px rgba(0,0,0,.08);
  }
  .flick-note{
    font-size:12px;
    font-weight:800;
    color:#0f172a;
    margin-bottom:6px;
  }
  .flick-grid{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:6px;
  }
  .flick-btn{
    border:none;
    border-radius:10px;
    padding:10px 12px;
    min-width:54px;
    font-size:17px;
    font-weight:800;
    background:linear-gradient(135deg, rgba(255,127,0,.92), rgba(229,0,113,.92));
    color:white;
    box-shadow:0 6px 14px rgba(229,0,113,.25);
    cursor:pointer;
    touch-action:none;
  }
  .flick-btn.opt{
    background:rgba(255,255,255,.92);
    color:#0f172a;
    border:1px solid rgba(229,0,113,.24);
    box-shadow:none;
    min-width:46px;
    padding:8px 10px;
  }
  .flick-btn.active{
    outline:3px solid rgba(3,115,138,.4);
  }
  .result-score{
    font-size:46px; font-weight:900; color:var(--accent);
  }
  .mistake{color:var(--accent); font-weight:800}
  .share-row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .hidden{display:none !important}
  .play-grid{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .play-lines{
    background:rgba(255,255,255,0.30);
    border-radius:14px;
    padding:14px 14px 10px;
    box-shadow:0 8px 24px rgba(0,0,0,.08);
    border:1px solid rgba(255,255,255,.38);
  }
  .play-lines .kanji,
  .play-lines .kana{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:clip;
  }
  .play-lines .kanji{
    min-height:44px;
  }
  .play-lines .kana{
    min-height:56px;
  }
  .kanji-next{
    background:#bde9f1;
    border-radius:6px;
    padding:1px 4px;
    color:#04586a;
  }
  .line-label{
    font-size:12px;
    font-weight:800;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:#44556e;
    margin-bottom:2px;
  }
  .overlay-count{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.55);
    color:white;
    font-size:68px;
    font-weight:900;
    z-index:50;
    pointer-events:none;
  }
  @media (max-width: 820px){
    .app{
      padding:8px;
      border-radius:16px;
    }
    .card{
      padding:12px;
    }
    .kana{
      font-size:25px;
    }
    .kanji{
      font-size:23px;
    }
    .stats{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:8px;
      font-size:13px;
      width:100%;
    }
    .stat{
      min-width:0;
      padding:6px 8px;
    }
    .ime-input{
      font-size:17px;
    }
    .bg-photo .bg-fill{
      object-position:50% 28%;
      opacity:.76;
    }
    .bg-photo .bg-main{
      object-position:center 70%;
      opacity:.82;
    }
  }
  @media (max-width: 480px){
    body{
      padding:10px;
    }
    h1{
      font-size:30px;
      letter-spacing:.02em;
    }
    .start-row{
      flex-direction:column;
      align-items:stretch;
      gap:8px;
    }
    .start-row .input,
    .start-row .btn{
      width:100%;
      max-width:none;
    }
    #name{
      height:42px;
      width:100%;
    }
    .start-row .btn{
      height:46px;
    }
    .muted{
      font-size:13px;
      line-height:1.4;
    }
    .ime-input{
      font-size:16px;
    }
  }
</style>
</head>
<body>
<div class="bg-photo">
  <img class="bg-fill" src="hero.jpg" alt="" onerror="this.parentElement.style.display='none';" />
  <img class="bg-main" src="hero.jpg" alt="" onerror="this.style.display='none';" />
</div>
<div class="app">
  <section id="screen-start" class="screen active">
    <h1>寿限無タイピング</h1>
    <div class="card">
      <div class="row start-row">
        <input id="name" class="input" maxlength="12" placeholder="なまえ" aria-label="なまえ" />
        <button id="startBtn" class="btn">Start</button>
      </div>
      <div class="muted" style="margin-top:6px; font-size:13px; font-weight:700">
        スマホ・タブレットはフリック専用キーボードで遊びます（OSキーボード不要）。
      </div>
      <div class="muted" style="margin-top:10px; font-size:14px">
        ルール：1文字ずつ正解で進みます。ミスごとに +1.0秒。貼り付けは禁止（無効）。
      </div>
      <div id="startWarn" class="warn hidden"></div>
    </div>
  </section>

  <section id="screen-play" class="screen">
    <div class="card">
      <div class="play-grid">
        <div class="stats">
          <div class="stat">経過: <span id="elapsed">0.0</span>s</div>
          <div class="stat">ミス: <span id="miss">0</span></div>
          <div class="stat">進捗: <span id="pos">0</span>/<span id="len">0</span></div>
          <div class="stat">達成率: <span id="progressPct">0.0</span>%</div>
          <div class="stat">次: <span id="nextChar">じ</span></div>
        </div>
        <div class="play-lines">
          <div class="line-label">漢字</div>
          <div id="kanjiLine" class="kanji"></div>
          <div class="line-label">ひらがな</div>
          <div id="kanaWindow" class="kana"></div>
        </div>
        <div class="progress-track"><div id="progressBar" class="progress-bar"></div></div>
        <div id="playWarn" class="warn hidden"></div>
      </div>
      <input id="typeInput" class="ime-input" inputmode="text" lang="ja" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" placeholder="" autofocus />
      <div id="flickArea" class="flick-wrap hidden">
        <div class="flick-note">スマホ向けフリック風キーボード</div>
        <div id="flickGrid" class="flick-grid"></div>
      </div>
    </div>
  </section>

  <section id="screen-result" class="screen">
    <div class="card">
      <div class="result-score"><span id="finalScore">0.0</span>s</div>
      <div class="row muted" style="margin-top:6px">
        <div>計測時間: <span id="timeRaw">0.0</span>s</div>
        <div>ミス回数: <span id="missRaw">0</span></div>
        <div>ペナルティ: +<span id="penaltyRaw">0.0</span>s</div>
      </div>
      <div style="margin-top:12px" id="resultKana" class="kana"></div>
      <div class="share-row" style="margin-top:12px">
        <button id="shareBtn" class="btn secondary hidden">共有</button>
        <button id="xBtn" class="btn ghost hidden">Xで共有</button>
        <button id="retryBtn" class="btn">もう一回</button>
      </div>
    </div>
  </section>
</div>
<div id="overlayCountdown" class="overlay-count hidden"></div>

<script>
(() => {
  const TEXT = "じゅげむじゅげむごこうのすりきれかいじゃりすいぎょのすいぎょうまつうんらいまつふうらいまつくうねるところにすむところやぶらこうじのぶらこうじぱいぽぱいぽぱいぽのしゅーりんがんしゅーりんがんのぐーりんだいぐーりんだいのぽんぽこぴーのぽんぽこなのちょうきゅうめいのちょうすけ";
  const KANJI_TEXT = "寿限無寿限無五劫の擦り切れ海砂利水魚の水行末雲来末風来末食う寝る処に住む処藪ら柑子の藪柑子パイポパイポパイポのシューリンガンシューリンガンのグーリンダイグーリンダイのポンポコピーのポンポコナーの長久命の長助";
  const SMALL_EQUIV = {
    "ぁ":"あ","ぃ":"い","ぅ":"う","ぇ":"え","ぉ":"お",
    "ゃ":"や","ゅ":"ゆ","ょ":"よ","ゎ":"わ","っ":"つ"
  };
  const ROMAJI_TO_KANA = {
    a:"あ",i:"い",u:"う",e:"え",o:"お",
    ka:"か",ki:"き",ku:"く",ke:"け",ko:"こ",
    sa:"さ",si:"し",su:"す",se:"せ",so:"そ",
    ta:"た",ti:"ち",tu:"つ",te:"て",to:"と",
    na:"な",ni:"に",nu:"ぬ",ne:"ね",no:"の",
    ha:"は",hi:"ひ",hu:"ふ",he:"へ",ho:"ほ",
    ma:"ま",mi:"み",mu:"む",me:"め",mo:"も",
    ya:"や",yu:"ゆ",yo:"よ",
    ra:"ら",ri:"り",ru:"る",re:"れ",ro:"ろ",
    wa:"わ",wo:"を",wi:"うぃ",we:"うぇ",
    ga:"が",gi:"ぎ",gu:"ぐ",ge:"げ",go:"ご",
    za:"ざ",zi:"じ",zu:"ず",ze:"ぜ",zo:"ぞ",
    da:"だ",di:"ぢ",du:"づ",de:"で",do:"ど",
    ba:"ば",bi:"び",bu:"ぶ",be:"べ",bo:"ぼ",
    pa:"ぱ",pi:"ぴ",pu:"ぷ",pe:"ぺ",po:"ぽ",
    vu:"ゔ",
    shi:"し",chi:"ち",tsu:"つ",fu:"ふ",ji:"じ",
    kya:"きゃ",kyu:"きゅ",kyo:"きょ",
    gya:"ぎゃ",gyu:"ぎゅ",gyo:"ぎょ",
    sya:"しゃ",syu:"しゅ",syo:"しょ",
    sha:"しゃ",shu:"しゅ",sho:"しょ",
    zya:"じゃ",zyu:"じゅ",zyo:"じょ",
    jya:"じゃ",jyu:"じゅ",jyo:"じょ",
    ja:"じゃ",ju:"じゅ",jo:"じょ",
    tya:"ちゃ",tyu:"ちゅ",tyo:"ちょ",
    cya:"ちゃ",cyu:"ちゅ",cyo:"ちょ",
    cha:"ちゃ",chu:"ちゅ",cho:"ちょ",
    nya:"にゃ",nyu:"にゅ",nyo:"にょ",
    hya:"ひゃ",hyu:"ひゅ",hyo:"ひょ",
    bya:"びゃ",byu:"びゅ",byo:"びょ",
    pya:"ぴゃ",pyu:"ぴゅ",pyo:"ぴょ",
    mya:"みゃ",myu:"みゅ",myo:"みょ",
    rya:"りゃ",ryu:"りゅ",ryo:"りょ",
    fa:"ふぁ",fi:"ふぃ",fe:"ふぇ",fo:"ふぉ",
    va:"ゔぁ",vi:"ゔぃ",ve:"ゔぇ",vo:"ゔぉ",
    lya:"ゃ",lyu:"ゅ",lyo:"ょ",
    xya:"ゃ",xyu:"ゅ",xyo:"ょ",
    ltsu:"っ",xtsu:"っ",
    la:"ぁ",li:"ぃ",lu:"ぅ",le:"ぇ",lo:"ぉ",
    xa:"ぁ",xi:"ぃ",xu:"ぅ",xe:"ぇ",xo:"ぉ"
  };
  const ROMAJI_KEYS = Object.keys(ROMAJI_TO_KANA);

  const el = (id) => document.getElementById(id);
  const screenStart = el("screen-start");
  const screenPlay = el("screen-play");
  const screenResult = el("screen-result");
  const kanjiLineEl = el("kanjiLine");
  const kanaWindowEl = el("kanaWindow");
  const resultKanaEl = el("resultKana");
  const typeInput = el("typeInput");
  const overlayCountdown = el("overlayCountdown");
  const startWarn = el("startWarn");
  const playWarn = el("playWarn");
  const nameInput = el("name");

  const elapsedEl = el("elapsed");
  const missEl = el("miss");
  const posEl = el("pos");
  const lenEl = el("len");
  const progressPctEl = el("progressPct");
  const nextCharEl = el("nextChar");
  const progressBarEl = el("progressBar");
  const flickArea = el("flickArea");
  const flickGrid = el("flickGrid");

  const finalScoreEl = el("finalScore");
  const timeRawEl = el("timeRaw");
  const missRawEl = el("missRaw");
  const penaltyRawEl = el("penaltyRaw");

  let pos = 0;
  let miss = 0;
  let penalty = 0;
  let startTime = 0;
  let timerId = null;
  let phase = "start"; // start, countdown, play, result
  let mistakedPosSet = new Set();
  let isComposing = false;
  let lastCompositionHandledAt = -1;
  let romajiBuffer = "";
  let usePCRealtime = false;
  let lastRealtimeKeyHandledAt = -1;
  let mobileHandledLen = 0;

  lenEl.textContent = TEXT.length.toString();
  const isMobileLike = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isCoarsePointer = window.matchMedia("(pointer:coarse)").matches;
  const isTouchCapable = ("ontouchstart" in window) || navigator.maxTouchPoints > 0;
  usePCRealtime = !(isMobileLike || isCoarsePointer || isTouchCapable);

  const FLICK_KEYS = [
    {label:"あ", base:"あ", left:"い", up:"う", right:"え", down:"お"},
    {label:"か", base:"か", left:"き", up:"く", right:"け", down:"こ"},
    {label:"さ", base:"さ", left:"し", up:"す", right:"せ", down:"そ"},
    {label:"た", base:"た", left:"ち", up:"つ", right:"て", down:"と"},
    {label:"な", base:"な", left:"に", up:"ぬ", right:"ね", down:"の"},
    {label:"は", base:"は", left:"ひ", up:"ふ", right:"へ", down:"ほ"},
    {label:"ま", base:"ま", left:"み", up:"む", right:"め", down:"も"},
    {label:"や", base:"や", left:"ゃ", up:"ゆ", right:"よ", down:"ゅ"},
    {label:"ら", base:"ら", left:"り", up:"る", right:"れ", down:"ろ"},
    {label:"゛", action:"cycle"}, // left/center: dakuten, right: handaku, down: small
    {label:"わ", base:"わ", left:"を", up:"ん", right:"ー", down:"ゎ"},
    {label:"？", base:"、", left:"。", up:"？", right:"！", down:"・"}
  ];
  let pressInfo = null;
  let pendingSmall = false;
  let pendingDakuten = false;
  let pendingHandaku = false;

  function syncInputMode(){
    if (usePCRealtime) {
      typeInput.classList.add("desktop-hidden");
      typeInput.classList.remove("mobile-hidden");
      typeInput.removeAttribute("placeholder");
      flickArea.classList.add("hidden");
      document.body.classList.remove("no-scroll");
    } else {
      typeInput.classList.remove("desktop-hidden");
      typeInput.classList.add("mobile-hidden");
      typeInput.setAttribute("placeholder", "");
      renderFlickKeyboard();
      flickArea.classList.remove("hidden");
      document.body.classList.add("no-scroll");
    }
  }

  function showScreen(name){
    screenStart.classList.toggle("active", name==="start");
    screenPlay.classList.toggle("active", name==="play");
    screenResult.classList.toggle("active", name==="result");
    phase = name;
  }

  function renderKanaWindow(){
    const kanaWindowSize = 10;
    const kanaStart = Math.max(0, Math.min(pos - 2, Math.max(0, TEXT.length - kanaWindowSize)));
    const kanaEnd = Math.min(TEXT.length, kanaStart + kanaWindowSize);
    const segment = TEXT.slice(kanaStart, kanaEnd);
    const before = segment.slice(0, pos - kanaStart);
    const current = segment[pos - kanaStart] || "";
    const after = segment.slice(pos - kanaStart + 1);

    kanaWindowEl.innerHTML =
      `<span class="done">${before}</span>` +
      (current ? `<span class="next">${current}</span>` : "") +
      after;

    const kanjiWindowSize = 10;
    const kanjiPos = Math.floor((pos / Math.max(1, TEXT.length - 1)) * Math.max(0, KANJI_TEXT.length - 1));
    const kanjiStart = Math.max(0, Math.min(kanjiPos - 2, Math.max(0, KANJI_TEXT.length - kanjiWindowSize)));
    const kanjiEnd = Math.min(KANJI_TEXT.length, kanjiStart + kanjiWindowSize);
    const kanjiSegment = KANJI_TEXT.slice(kanjiStart, kanjiEnd);
    const kanjiCursor = kanjiPos - kanjiStart;
    const kanjiBefore = kanjiSegment.slice(0, kanjiCursor);
    const kanjiCurrent = kanjiSegment[kanjiCursor] || "";
    const kanjiAfter = kanjiSegment.slice(kanjiCursor + 1);
    kanjiLineEl.innerHTML =
      `<span class="done">${kanjiBefore}</span>` +
      (kanjiCurrent ? `<span class="kanji-next">${kanjiCurrent}</span>` : "") +
      kanjiAfter;

    updateProgressUI();
  }

  function updateProgressUI(){
    const ratio = Math.min(1, pos / TEXT.length);
    progressPctEl.textContent = (ratio * 100).toFixed(1);
    progressBarEl.style.width = `${(ratio * 100).toFixed(1)}%`;
    nextCharEl.textContent = pos < TEXT.length ? TEXT[pos] : "完了";
  }

  function renderFlickKeyboard(){
    if (usePCRealtime) return;
    flickGrid.innerHTML = FLICK_KEYS.map((k,i)=>
      `<button class="flick-btn" data-key="${i}">${k.label}</button>`
    ).join("");
  }

  function renderResultKana(){
    const chars = TEXT.split("");
    const html = chars.map((ch, i) => {
      if (mistakedPosSet.has(i)) return `<span class="mistake">${ch}</span>`;
      return ch;
    }).join("");
    resultKanaEl.innerHTML = html;
  }

  function resetState(){
    pos = 0;
    miss = 0;
    penalty = 0;
    mistakedPosSet = new Set();
    elapsedEl.textContent = "0.0";
    missEl.textContent = "0";
    posEl.textContent = "0";
    renderKanaWindow();
    typeInput.value = "";
    isComposing = false;
    lastCompositionHandledAt = -1;
    romajiBuffer = "";
    lastRealtimeKeyHandledAt = -1;
    mobileHandledLen = 0;
  }

  function startCountdown(){
    showScreen("play");
    resetState();
    playWarn.classList.add("hidden");
    overlayCountdown.classList.remove("hidden");
    let c = 3;
    overlayCountdown.textContent = c.toString();
    phase = "countdown";

    const tick = () => {
      c -= 1;
      if (c > 0){
        overlayCountdown.textContent = c.toString();
        setTimeout(tick, 1000);
      } else {
        overlayCountdown.textContent = "GO";
        setTimeout(() => {
          overlayCountdown.classList.add("hidden");
          beginPlay();
        }, 600);
      }
    };
    setTimeout(tick, 1000);
  }

  function beginPlay(){
    phase = "play";
    startTime = performance.now();
    if (timerId) clearInterval(timerId);
    timerId = setInterval(() => {
      if (phase !== "play") return;
      const t = (performance.now() - startTime) / 1000;
      elapsedEl.textContent = t.toFixed(1);
    }, 100);

    typeInput.disabled = false;
    typeInput.readOnly = false;
    typeInput.setAttribute("inputmode", "text");
    syncInputMode();
    playWarn.classList.add("hidden");
    typeInput.value = "";
    focusTypingInput();
  }

  function focusTypingInput(){
    if (phase !== "play") return;
    if (usePCRealtime){
      typeInput.focus({preventScroll:true});
      playWarn.classList.add("hidden");
      setTimeout(() => typeInput.scrollIntoView({block:"center"}), 50);
    } else {
      typeInput.blur();
    }
  }

  function finishPlay(){
    phase = "result";
    if (timerId) clearInterval(timerId);
    const timeRaw = (performance.now() - startTime) / 1000;
    const finalScore = timeRaw + penalty;

    timeRawEl.textContent = timeRaw.toFixed(2);
    missRawEl.textContent = miss.toString();
    penaltyRawEl.textContent = penalty.toFixed(1);
    finalScoreEl.textContent = finalScore.toFixed(2);

    renderResultKana();
    showScreen("result");
    setupShare(finalScore);
  }

  function isHiraganaOrLong(ch){
    return /[ぁ-ゖー]/.test(ch);
  }

  function isKanaMatch(inputChar, expectedChar){
    if (inputChar === expectedChar) return true;
    return SMALL_EQUIV[expectedChar] === inputChar;
  }

  function handleChars(str){
    for (const ch of str){
      if (!isHiraganaOrLong(ch)) continue;
      if (isKanaMatch(ch, TEXT[pos])){
        pos += 1;
        posEl.textContent = pos.toString();
        if (pos >= TEXT.length){
          renderKanaWindow();
          finishPlay();
          return;
        }
      } else {
        addMiss();
      }
    }
    renderKanaWindow();
  }

  function addMiss(){
    if (pos >= TEXT.length) return;
    miss += 1;
    penalty += 1.0;
    missEl.textContent = miss.toString();
    mistakedPosSet.add(pos);
  }

  function applySmall(ch){
    const m = {
      "あ":"ぁ","い":"ぃ","う":"ぅ","え":"ぇ","お":"ぉ",
      "や":"ゃ","ゆ":"ゅ","よ":"ょ",
      "つ":"っ","わ":"ゎ"
    };
    return m[ch] || ch;
  }

  function applyDakuten(ch){
    const m = {
      "か":"が","き":"ぎ","く":"ぐ","け":"げ","こ":"ご",
      "さ":"ざ","し":"じ","す":"ず","せ":"ぜ","そ":"ぞ",
      "た":"だ","ち":"ぢ","つ":"づ","て":"で","と":"ど",
      "は":"ば","ひ":"び","ふ":"ぶ","へ":"べ","ほ":"ぼ",
      "う":"ゔ"
    };
    return m[ch] || ch;
  }

  function applyHandaku(ch){
    const m = {
      "は":"ぱ","ひ":"ぴ","ふ":"ぷ","へ":"ぺ","ほ":"ぽ"
    };
    return m[ch] || ch;
  }

  function hasRomajiPrefix(prefix){
    for (const key of ROMAJI_KEYS){
      if (key.startsWith(prefix)) return true;
    }
    return false;
  }

  function processCommittedText(raw){
    if (!raw) return;
    const normalized = raw.normalize("NFC");
    let kanaOut = "";

    for (const ch of normalized){
      if (isHiraganaOrLong(ch)){
        if (romajiBuffer){
          const flushed = convertRomajiBuffer(true);
          kanaOut += flushed;
        }
        kanaOut += ch;
        continue;
      }
      if (/[A-Za-z\-']/.test(ch)){
        romajiBuffer += ch.toLowerCase();
        kanaOut += convertRomajiBuffer(false);
        continue;
      }
      if (romajiBuffer){
        kanaOut += convertRomajiBuffer(true);
      }
    }

    if (kanaOut){
      handleChars(kanaOut);
    }
  }

  function processMobileDelta(){
    const normalized = (typeInput.value || "").normalize("NFC");
    if (!normalized) return;
    processCommittedText(normalized);
    typeInput.value = "";
  }

  function emitFlickChar(rawCh){
    if (!rawCh) return;
    let ch = rawCh;
    if (pendingSmall){
      ch = applySmall(ch);
      pendingSmall = false;
    }
    if (pendingDakuten){
      ch = applyDakuten(ch);
      pendingDakuten = false;
    }
    if (pendingHandaku){
      ch = applyHandaku(ch);
      pendingHandaku = false;
    }
    handleChars(ch);
  }

  function decideChar(key, dir){
    if (key.action === "cycle"){
      if (!dir || dir === "left"){
        pendingDakuten = true;
        pendingHandaku = false;
        pendingSmall = false;
      } else if (dir === "right"){
        pendingHandaku = true;
        pendingDakuten = false;
        pendingSmall = false;
      } else if (dir === "down"){
        pendingSmall = true;
        pendingDakuten = false;
        pendingHandaku = false;
      }
      return null;
    }
    if (!key.base) return null;
    if (!dir) return key.base;
    if (dir === "left" && key.left) return key.left;
    if (dir === "up" && key.up) return key.up;
    if (dir === "right" && key.right) return key.right;
    if (dir === "down" && key.down) return key.down;
    return key.base;
  }

  function convertRomajiBuffer(flush){
    let out = "";
    let i = 0;

    while (i < romajiBuffer.length){
      const ch = romajiBuffer[i];

      if (ch === "-"){
        out += "ー";
        i += 1;
        continue;
      }
      if (ch === "'"){
        i += 1;
        continue;
      }
      if (!/[a-z]/.test(ch)){
        i += 1;
        continue;
      }

      const next = romajiBuffer[i + 1] || "";
      if (ch === "n"){
        if (!next){
          if (flush){
            out += "ん";
            i += 1;
          }
          break;
        }
        if (next === "n"){
          out += "ん";
          i += 2;
          continue;
        }
        if (!/[aiueoy]/.test(next)){
          out += "ん";
          i += 1;
          continue;
        }
      }

      if (
        next &&
        ch === next &&
        /[bcdfghjklmpqrstvwxyz]/.test(ch) &&
        ch !== "n"
      ){
        out += "っ";
        i += 1;
        continue;
      }

      let matched = false;
      for (let len = 4; len >= 1; len -= 1){
        const seg = romajiBuffer.slice(i, i + len);
        const kana = ROMAJI_TO_KANA[seg];
        if (kana){
          out += kana;
          i += len;
          matched = true;
          break;
        }
      }
      if (matched) continue;

      if (flush){
        addMiss();
        i += 1;
        continue;
      }
      const rest = romajiBuffer.slice(i);
      if (!hasRomajiPrefix(rest)){
        addMiss();
        i += 1;
        continue;
      }
      break;
    }

    romajiBuffer = romajiBuffer.slice(i);
    return out;
  }

  function softReset(message){
    if (timerId) clearInterval(timerId);
    showScreen("start");
    startWarn.textContent = message;
    startWarn.classList.remove("hidden");
  }

  el("startBtn").addEventListener("click", () => {
    startWarn.classList.add("hidden");
    startCountdown();
    setTimeout(() => focusTypingInput(), 30);
  });

  el("retryBtn").addEventListener("click", () => {
    showScreen("start");
  });

  screenPlay.addEventListener("click", () => {
    if (phase !== "play" || usePCRealtime) return;
    focusTypingInput();
  });

  typeInput.addEventListener("beforeinput", (e) => {
    if (phase !== "play") {
      e.preventDefault();
      return;
    }
    if (!usePCRealtime && e.inputType === "insertLineBreak") {
      e.preventDefault();
      typeInput.value = "";
    }
  });

  document.addEventListener("keydown", (e) => {
    if (phase !== "play" || !usePCRealtime) return;
    if (e.target === nameInput) return;
    if (e.ctrlKey || e.altKey || e.metaKey) return;
    if (e.key === "Tab") return;

    if (e.key === "Backspace") {
      e.preventDefault();
      if (romajiBuffer.length > 0) romajiBuffer = romajiBuffer.slice(0, -1);
      typeInput.value = "";
      return;
    }

    if (e.key === "Enter" || e.key === " ") {
      e.preventDefault();
      const flushed = convertRomajiBuffer(true);
      if (flushed) handleChars(flushed);
      typeInput.value = "";
      return;
    }

    if (e.key.length === 1) {
      if (/[A-Za-z\-']/.test(e.key) || isHiraganaOrLong(e.key)) {
        e.preventDefault();
        processCommittedText(e.key);
        lastRealtimeKeyHandledAt = performance.now();
        typeInput.value = "";
        return;
      }
      e.preventDefault();
    }
  });

  typeInput.addEventListener("input", (e) => {
    if (phase !== "play") {
      typeInput.value = "";
      return;
    }
    if (e.inputType === "insertFromPaste") {
      softReset("貼り付けは無効です。リセットしました。");
      return;
    }
    if (usePCRealtime) {
      if (lastCompositionHandledAt > 0 && performance.now() - lastCompositionHandledAt < 40) {
        typeInput.value = "";
        return;
      }
      if (lastRealtimeKeyHandledAt > 0 && performance.now() - lastRealtimeKeyHandledAt < 40) {
        typeInput.value = "";
        return;
      }
    }
    if (!usePCRealtime) {
      processMobileDelta();
      return;
    }
    if (isComposing || e.isComposing) return;
    processCommittedText(typeInput.value || "");
    typeInput.value = "";
  });

  typeInput.addEventListener("compositionstart", () => {
    if (phase !== "play") return;
    isComposing = true;
  });

  typeInput.addEventListener("blur", () => {
    if (phase !== "play") return;
    if (!usePCRealtime) return;
    playWarn.textContent = "入力が外れました。画面をタップして再開してください。";
    playWarn.classList.remove("hidden");
  });

  typeInput.addEventListener("compositionend", (e) => {
    if (phase !== "play") {
      typeInput.value = "";
      return;
    }
    isComposing = false;
    if (!usePCRealtime) {
      if (typeInput.value) processMobileDelta();
    } else {
      const committed = e.data || typeInput.value || "";
      processCommittedText(committed);
      typeInput.value = "";
    }
    lastCompositionHandledAt = performance.now();
  });


  typeInput.addEventListener("paste", (e) => {
    e.preventDefault();
    softReset("貼り付けは無効です。リセットしました。");
  });

  typeInput.addEventListener("drop", (e) => {
    e.preventDefault();
    softReset("ドロップ入力は無効です。リセットしました。");
  });

  document.addEventListener("paste", (e) => {
    if (phase !== "play") return;
    e.preventDefault();
    softReset("貼り付けは無効です。リセットしました。");
  });

  document.addEventListener("drop", (e) => {
    if (phase !== "play") return;
    e.preventDefault();
    softReset("ドロップ入力は無効です。リセットしました。");
  });

  function handlePressStart(clientX, clientY, keyIdx){
    pressInfo = {x:clientX, y:clientY, keyIdx};
  }

  function handlePressEnd(clientX, clientY, keyIdx){
    if (pressInfo && pressInfo.keyIdx !== keyIdx){
      pressInfo = null;
      return;
    }
    const info = pressInfo;
    pressInfo = null;
    const key = FLICK_KEYS[keyIdx];
    if (!key) return;
    let dir = null;
    if (info){
      const dx = clientX - info.x;
      const dy = clientY - info.y;
      const threshold = 22;
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold){
        dir = dx > 0 ? "right" : "left";
      } else if (Math.abs(dy) > threshold){
        dir = dy > 0 ? "down" : "up";
      }
    }
    const ch = decideChar(key, dir);
    if (ch) emitFlickChar(ch);
  }

  flickGrid.addEventListener("touchstart", (e) => {
    const t = e.changedTouches[0];
    const btn = document.elementFromPoint(t.clientX, t.clientY)?.closest("button[data-key]");
    if (!btn) return;
    handlePressStart(t.clientX, t.clientY, Number(btn.dataset.key));
  }, {passive:true});

  flickGrid.addEventListener("touchend", (e) => {
    const t = e.changedTouches[0];
    const btn = document.elementFromPoint(t.clientX, t.clientY)?.closest("button[data-key]");
    if (!btn) { pressInfo=null; return; }
    handlePressEnd(t.clientX, t.clientY, Number(btn.dataset.key));
    e.preventDefault();
  }, {passive:false});

  flickGrid.addEventListener("mousedown", (e) => {
    const btn = e.target.closest("button[data-key]");
    if (!btn) return;
    handlePressStart(e.clientX, e.clientY, Number(btn.dataset.key));
  });

  flickGrid.addEventListener("mouseup", (e) => {
    const btn = e.target.closest("button[data-key]");
    if (!btn) return;
    handlePressEnd(e.clientX, e.clientY, Number(btn.dataset.key));
  });

  flickGrid.addEventListener("click", (e) => {
    const btn = e.target.closest("button[data-key]");
    if (!btn) return;
    if (pressInfo) return;
    const key = FLICK_KEYS[Number(btn.dataset.key)];
    const ch = decideChar(key, null);
    if (ch) emitFlickChar(ch);
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden && phase === "play") {
      playWarn.textContent = "画面が非アクティブになりました（失格にはなりません）。";
      playWarn.classList.remove("hidden");
    }
  });

  function setupShare(finalScore){
    const missCount = miss;
    const text = `寿限無タイピング：${finalScore.toFixed(2)}秒（ミス${missCount} / +${penalty.toFixed(1)}秒）\n#寿限無タイピング`;
    const url = location.href;

    const shareBtn = el("shareBtn");
    const xBtn = el("xBtn");

    if (navigator.share) {
      shareBtn.classList.remove("hidden");
      xBtn.classList.add("hidden");
      shareBtn.onclick = () => {
        navigator.share({text: `${text}\n${url}`}).catch(() => {});
      };
    } else {
      shareBtn.classList.add("hidden");
      xBtn.classList.remove("hidden");
      xBtn.onclick = () => {
        const shareUrl = "https://x.com/intent/post?text=" + encodeURIComponent(`${text}\n${url}`);
        window.open(shareUrl, "_blank");
      };
    }
  }

  // Initial render
  syncInputMode();
  renderKanaWindow();
})();
</script>
</body>
</html>
